A. FSA to RegExp Translator
time limit per test1 second
memory limit per test16 megabytes
inputinput.txt
Implement an FSA to RegExp Translator. Given an FSA description in the input.txt (see input file format) your program should output to console an error description (see validation errors) OR a regular expression that corresponds to the given FSA. Assume that deterministic and non-deterministic FSAs may be inserted. However, epsilon-moves are guaranteed NOT to be used as inputs for any FSA types. The regular expression should be built according to a slightly modified version of the Kleene's algorithm (see Kleene's algorithm).

Input
type=[t] // t ∈ {deterministic, non-deterministic}

states=[s1,s2,...] // s1 , s2, ... ∈ latin letters, words and numbers

alphabet=[a1,a2,...] // a1 , a2, ... ∈ latin letters, words, numbers and character '_' (underscore)

initial=[s] // s ∈ states

accepting=[s1,s2,...] // s1, s2 ∈ states

transitions=[s1>a>s2,...] // s1,s2,...∈ states; a ∈ alphabet

Output
Error message or calculated regular expression

Examples
InputСкопировать
type=[deterministic]
states=[on,off]
alphabet=[turn_on,turn_off]
initial=[off]
accepting=[on]
transitions=[off>turn_on>off,on>turn_off>on]
OutputСкопировать
E6: Some states are disjoint
InputСкопировать
type=[non-deterministic]
states=[q0,q1]
alphabet=[0,1]
initial=[q0]
accepting=[q1]
transitions=[q0>1>q0,q0>0>q1]
OutputСкопировать
(((1|eps)(1|eps)*(0)|(0))(({})(1|eps)*(0)|(eps))*(({})(1|eps)*(0)|(eps))|((1|eps)(1|eps)*(0)|(0)))
InputСкопировать
type=[non-deterministic]
states=[q0,q1]
alphabet=[0,1]
initial=[q0]
accepting=[q1]
transitions=[q0>0>q0,q0>1>q0,q1>0>q1,q1>1>q1,q1>0>q0,q1>1>q0]
OutputСкопировать
E6: Some states are disjoint
Note
Errors: The errors may appear in the inputs, which should lead to error message according to the priority given below and to program termination. Only 1 error message should be shown, if required. It should be assumed that for each line read from the inputs all the possible errors should be checked in the given priority, if applicable for the current line.

E1: Input file is malformed // related to anything breaking the current expected line structure
E2: Initial state is not defined
E3: Set of accepting states is empty
E4: A state 's' is not in the set of states // related to non-empty states
E5: A transition 'a' is not represented in the alphabet // related to non-empty transitions
E6: Some states are disjoint
E7: FSA is non-deterministic
Kleene's Algorithm:

The Kleene's Algorithm should be used as presented in the Lab 10, but with following modifications:

Denote ∅ as {}

Denote Ɛ as eps

Define update rule with the additional parentheses: Rkij=(Rk−1ik)(Rk−1kk)∗(Rk−1kj)|(Rk−1ij)

At each step each regular expression should be surrounded by parentheses, e.g. Rkij=((a|eps)(a|eps)∗(a|eps)|(a|eps))

Optimization of the regular expressions should NOT be done

The regular expression parts' content should be in lexicographical order, but Ɛ should be at the end of each part, e.g. (a|b|eps)∗

Assume that input files and standard outputs should end with a new line character

